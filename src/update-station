#!/usr/local/bin/python
"""This is the main file for the update-station application"""

import bectl
import datetime
import getpass
import gi
import json
import os
import gettext
import re
import socket
import sys
import threading
import distro
gi.require_version('Gtk', '3.0')
gi.require_version('Notify', '0.7')
from gi.repository import Gtk, GLib, Notify
from subprocess import Popen, PIPE, run
from time import sleep
from update_data import Data
from updateHandler import (
    check_for_update,
    get_pkg_upgrade_data,
    network_stat,
    repo_online,
    look_update_station,
    unlock_update_station,
    updating,
    repository_is_syncing,
    is_major_upgrade_available,
    get_abi_upgrade,
    get_current_abi,
    find_if_os_generic_exists,
    remove_os_generic,
    install_ghostbsd_pkgbase,
    set_package_base_config_file,
    restore_vital_files,
    remove_package_config
)
gettext.bindtextdomain('update-station', '/usr/local/share/locale')
gettext.textdomain('update-station')
_ = gettext.gettext

lib_path: str = f'{sys.prefix}/lib/update-station'

__VERSION__ = '5.2'

username = os.environ.get('SUDO_USER') if 'SUDO_USER' in os.environ else getpass.getuser()
home = os.path.expanduser('~')


class UpdateWindow:
    """
    Class that creates the main window to see update list and start the update process.
    """
    def delete_event(self, widget: Gtk.Widget) -> None:
        """
        Function that handles the delete event when the window is closed.
        :param widget: The widget that triggered the delete event.
        """
        if Data.close_session is True:
            if updating():
                unlock_update_station()
            Gtk.main_quit()
        else:
            self.window.destroy()
            if Data.update_started is False:
                Data.stop_pkg_refreshing = False
                if updating():
                    unlock_update_station()
                tray.tray_icon().set_visible(True)

    def start_update(self, widget):
        """
        Function that starts the update process.
        :param widget: The widget that triggered the start update event.
        """
        Data.update_started = True
        InstallUpdate()
        self.window.hide()

    def if_backup(self, widget):
        """
        Function that handles the backup checkbox.
        :param widget: The widget that triggered the checkbox event.
        """
        Data.backup = widget.get_active()

    def create_bbox(self):
        """
        Function that creates the button box.
        :return: The button box.
        """
        table = Gtk.Table(
            n_rows=1,
            n_columns=5,
            homogeneous=False,
            column_spacing=5
        )
        backup_checkbox = Gtk.CheckButton(
            label=_("Create boot environment backup")
        )
        table.attach(backup_checkbox, 0, 1, 0, 1)
        backup_checkbox.connect("toggled", self.if_backup)
        if bectl.is_file_system_zfs() and Data.second_update is False:
            backup_checkbox.set_active(True)
            backup_checkbox.set_sensitive(True)
            Data.backup = True
        else:
            backup_checkbox.set_active(False)
            backup_checkbox.set_sensitive(False)
            Data.backup = False
        img = Gtk.Image(icon_name='window-close')
        close_button = Gtk.Button(label=_("Close"))
        close_button.set_image(img)
        table.attach(close_button, 3, 4, 0, 1)
        close_button.connect("clicked", self.delete_event)
        install_button = Gtk.Button(label=_("Install update"))
        table.attach(install_button, 4, 5, 0, 1)
        install_button.connect("clicked", self.start_update)
        return table

    def __init__(self):
        """
        The constructor for the UpdateWindow class.
        """
        self.window = Gtk.Window()
        self.window.connect("destroy", self.delete_event)
        self.window.set_size_request(700, 400)
        self.window.set_resizable(False)
        self.window.set_title(_("Update Manager"))
        self.window.set_border_width(0)
        self.window.set_position(Gtk.WindowPosition.CENTER)
        self.window.set_default_icon_name('system-software-update')
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        self.window.add(box1)
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=0)
        box2.set_border_width(20)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        # Title
        title_text = _("Updates available!")

        update_title_label = Gtk.Label(
            label=f"<b><span size='large'>{title_text}</span></b>"
        )
        update_title_label.set_use_markup(True)
        box2.pack_start(update_title_label, False, False, 0)
        self.tree_store = Gtk.TreeStore(str, bool)
        sw = Gtk.ScrolledWindow()
        sw.set_shadow_type(Gtk.ShadowType.ETCHED_IN)
        sw.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        self.view = Gtk.TreeView(model=self.store())
        self.renderer = Gtk.CellRendererText()
        self.column0 = Gtk.TreeViewColumn("Name", self.renderer, text=0)
        self.view.append_column(self.column0)
        self.view.set_headers_visible(False)
        sw.add(self.view)
        sw.show()
        box2.pack_start(sw, True, True, 10)
        box2 = Gtk.HBox(homogeneous=False, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, False, 5)
        box2.show()
        # Add button
        box2.pack_start(self.create_bbox(), True, True, 10)
        self.window.show_all()

    def store(self):
        """
        Function that creates the store for the list of package in the treeview.
        :return: The store for the list of package to be updated.
        """
        self.tree_store.clear()
        r_num = 0
        u_num = 0
        i_num = 0
        ri_num = 0
        if bool(Data.packages_dictionary['remove']):
            r_num = len(Data.packages_dictionary['remove'])
            message = _('Installed packages to be REMOVED:')
            message += f' {r_num}'
            r_pinter = self.tree_store.append(None, (message, True))
            for line in Data.packages_dictionary['remove']:
                self.tree_store.append(r_pinter, (line, True))
        if bool(Data.packages_dictionary['upgrade']):
            u_num = len(Data.packages_dictionary['upgrade'])
            message = _('Installed packages to be UPGRADED')
            message += f' {u_num}'
            u_pinter = self.tree_store.append(None, (message, True))
            for line in Data.packages_dictionary['upgrade']:
                self.tree_store.append(u_pinter, (line, True))
        if bool(Data.packages_dictionary['install']):
            i_num = len(Data.packages_dictionary['install'])
            message = _('New packages to be INSTALLED:')
            message += f' {i_num}'
            i_pinter = self.tree_store.append(None, (message, True))
            for line in Data.packages_dictionary['install']:
                self.tree_store.append(i_pinter, (line, True))
        if bool(Data.packages_dictionary['reinstall']):
            ri_num = len(Data.packages_dictionary['reinstall'])
            message = _('Installed packages to be REINSTALLED:')
            message += f' {ri_num}'
            ri_pinter = self.tree_store.append(None, (message, True))
            for line in Data.packages_dictionary['reinstall']:
                self.tree_store.append(ri_pinter, (line, True))
        Data.total_packages = r_num + u_num + i_num + ri_num
        return self.tree_store

    def display(self, model: Gtk.TreeStore) -> Gtk.TreeView:
        """
        Function that creates the treeview.

        :param model: The store for the list of package to be updated.
        :return: The treeview.
        """
        self.view = Gtk.TreeView(model=model)
        self.renderer = Gtk.CellRendererText()
        self.column0 = Gtk.TreeViewColumn("Name", self.renderer, text=0)
        self.view.append_column(self.column0)
        self.view.set_headers_visible(False)
        return self.view


class UpdateNotifier:
    """
    Class that creates the notification for the update.
    """

    def __init__(self):
        """
        The constructor for the UpdateNotifier class.
        """
        self.notification = None
        Notify.init('Test')
        self.msg = _("Software updates are now available.")
        self.timeout = 10000  # 10 seconds

    def notify(self):
        """
        Function that creates the notification for the update.
        """
        if Data.major_upgrade is True:
            self.msg = _("Major system version upgrade is now available.")
        elif Data.kernel_upgrade is True:
            self.msg = _("System and software updates are now available.")
        self.notification = Notify.Notification.new(
            summary=_('Update Available'),
            body=self.msg,
            icon='system-software-update'
        )
        self.notification.add_action('clicked', 'Start Upgrade', self.on_activated)
        self.notification.show()

    def on_activated(self, notification, action_name):
        """
        Function that starts the upgrade.
        :param notification: The notification widget.
        :param action_name: The name of the action.
        """
        if Data.major_upgrade is True:
            MajorUpgradeWindow()
        else:
            StartCheckUpdate()
        notification.close()
        GLib.idle_add(tray.tray_icon().set_visible, False)


class MajorUpgradeWindow(Gtk.Window):
    """
    Class that creates the window for the major upgrade.
    """

    def __init__(self):
        """
        The constructor for the MajorUpgradeWindow class.
        """
        Gtk.Window.__init__(self, title=_("Major version upgrade"))
        self.connect("destroy", Gtk.main_quit)
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        vbox.set_border_width(10)
        self.add(vbox)

        label = Gtk.Label(
            label=_(f"Would you like to upgrade from {Data.current_abi} to {Data.new_abi}?"
                    "\n\nIf you select No, the upgrade will be skipped until the next boot.")
        )
        vbox.pack_start(label, True, True, 5)
        hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        vbox.pack_start(hbox, False, False, 0)
        button1 = Gtk.Button(label="Yes")
        button1.connect("clicked", self.on_clicked)
        hbox.pack_end(button1, True, True, 0)

        button2 = Gtk.Button(label="No")
        button2.connect("clicked", self.on_clicked)
        hbox.pack_end(button2, True, True, 0)
        self.show_all()

    def on_clicked(self, widget):
        """
        Function that starts the upgrade.
        :param widget: The widget that was clicked.
        """
        if widget.get_label() == "Yes":
            Data.major_upgrade = True
            Data.do_not_upgrade = False
            StartCheckUpdate()
        else:
            Data.major_upgrade = False
            Data.do_not_upgrade = True
        self.hide()


class TrayIcon:
    """
    The class for the tray icon.
    """

    def tray_icon(self):
        return self.status_icon

    def __init__(self):
        """
        The constructor for the TrayIcon class.
        """
        self.status_icon = Gtk.StatusIcon()
        self.status_icon.set_tooltip_text('Update Available')
        self.menu = Gtk.Menu()
        self.menu.show_all()
        self.status_icon.connect("activate", self.left_click)
        self.status_icon.connect('popup-menu', self.icon_clicked)
        self.status_icon.set_visible(False)
        self.status_icon.set_from_icon_name('system-software-update')

    def nm_menu(self):
        """
        Function that creates the menu for the tray icon.
        :return: The menu.
        """
        self.menu = Gtk.Menu()
        open_update = Gtk.MenuItem(label=_("Open Update"))
        open_update.connect("activate", self.left_click)
        close_item = Gtk.MenuItem(label=_("Close"))
        close_item.connect("activate", Gtk.main_quit)
        self.menu.append(open_update)
        self.menu.append(close_item)
        self.menu.show_all()
        return self.menu

    def left_click(self, status_icon: Gtk.StatusIcon):
        """
        Function that is called when the user left-clicks on the tray icon.
        :param status_icon: The status icon.
        """
        if updating():
            UpdateStationOpen()
        else:
            Data.stop_pkg_refreshing = True
            if Data.major_upgrade is True:
                MajorUpgradeWindow()
            else:
                StartCheckUpdate()
        status_icon.set_visible(False)

    def icon_clicked(self, status_icon, button, time):
        """
        Function that is called when the user right-clicks on the tray icon.
        :param status_icon: The status icon.
        :param button: The button.
        :param time: The time.
        """
        position = Gtk.StatusIcon.position_menu
        self.nm_menu().popup(None, None, position, status_icon, button, time)

    def update_tray(self):
        """
        Function that updates the tray icon.
        """
        if find_if_os_generic_exists():
            UpgradeToPKGBase()
        elif check_for_update():
            GLib.idle_add(self.status_icon.set_visible, True)
            notifier = UpdateNotifier()
            notifier.notify()
        elif is_major_upgrade_available() and Data.do_not_upgrade is False:
            Data.major_upgrade = True
            GLib.idle_add(self.status_icon.set_visible, True)
            Data.current_abi = get_current_abi()
            Data.new_abi = get_abi_upgrade()
            notifier = UpdateNotifier()
            notifier.notify()
        else:
            GLib.idle_add(self.status_icon.set_visible, False)

    def threading_update(self):
        """
        Function that creates a thread that checks for updates.
        """
        if updating():
            unlock_update_station()
        thr = threading.Thread(target=self.check, daemon=True)
        thr.start()

    def check(self):
        """
        Function that checks for updates.
        """
        while True:
            sleep(120)
            if not repository_is_syncing():
                if not Data.stop_pkg_refreshing:
                    if not updating():
                        GLib.idle_add(self.update_tray)
                    else:
                        GLib.idle_add(self.status_icon.set_visible, False)
            # Wait for an hour to look for update
            sleep(600)


class UpgradeToPKGBase(Gtk.Window):
    def __init__(self):
        Gtk.Window.__init__(self, title=_("Upgrade to PKGBASE"))
        self.connect("destroy", Gtk.main_quit)
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        vbox.set_border_width(10)
        self.add(vbox)
        label = Gtk.Label(label=_("To continue receiving system updates, you need to upgrade to PKGBASE.\n\n"
                                  "This upgrade cannot be performed on a UFS installation. If you have \n"
                                  "installed GhostBSD with UFS, please cancel and reinstall using ZFS.\n\n"
                                  "This upgrade will be performed in a new boot environment and will\n"
                                  "automatically reboot into it."))
        vbox.pack_start(label, True, True, 5)

        hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        vbox.pack_end(hbox, False, False, 0)
        upgrade_button = Gtk.Button(label=_("Upgrade Now"))
        upgrade_button.connect("clicked", self.on_clicked)
        hbox.pack_end(upgrade_button, False, False, 0)
        cancel_button = Gtk.Button(label=_("Cancel"))
        cancel_button.connect("clicked", Gtk.main_quit)
        hbox.pack_end(cancel_button, False, False, 0)

        self.show_all()

    def on_clicked(self, widget):
        self.hide()
        UpgradePKGBASEProgress()


class UpgradePKGBASEProgress:
    """
    The class for the window that is displayed the progress of the update.
    """
    def close_application(self, widget, data):
        if updating():
            unlock_update_station()
        Gtk.main_quit()

    def __init__(self):
        """
        The constructor for the InstallUpdate class.
        """
        self.win = Gtk.Window()
        self.win.connect("delete-event", self.close_application)
        self.win.set_size_request(500, 75)
        self.win.set_resizable(False)
        self.win.set_title(_("Upgrading to PKGBASE"))
        self.win.set_border_width(0)
        self.win.set_position(Gtk.WindowPosition.CENTER)
        self.win.set_default_icon_name('system-software-update')
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        self.win.add(box1)
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        self.pbar = Gtk.ProgressBar()
        self.pbar.set_show_text(True)
        self.pbar.set_fraction(0.0)
        # self.pbar.set_size_request(-1, 20)
        box2.pack_start(self.pbar, False, False, 0)
        self.win.show_all()
        self.thr = threading.Thread(
            target=self.read_output,
            args=[self.pbar],
            daemon=True
        )
        self.thr.start()

    def update_progress(self, progress, fraction, text):
        """
        Function that updates the progress bar.
        :param progress: The progress bar.
        :param fraction: The fraction to add.
        :param text: The text to display.
        """
        progress.set_fraction(fraction)
        progress.set_text(text)

    def read_output(self, progress):
        fraction = 1.0 / 18
        progress_text = _("Setting temporary packages configuration")
        GLib.idle_add(self.update_progress, progress, fraction, progress_text)
        assert set_package_base_config_file().returncode == 0
        progress_text = _("Temporary packages configuration setting completed")
        GLib.idle_add(self.update_progress, progress, progress.get_fraction() + fraction, progress_text)
        sleep(1)
        progress_text = _("Creating boot environment pkgbase-upgrade")
        GLib.idle_add(self.update_progress, progress, progress.get_fraction() + fraction, progress_text)
        bectl.create_be('pkgbase-upgrade')
        progress_text = _("Boot environment pkgbase-upgrade created")
        GLib.idle_add(self.update_progress, progress, progress.get_fraction() + fraction, progress_text)
        sleep(1)
        progress_text = _("Mounting boot environment pkgbase-upgrade")
        GLib.idle_add(self.update_progress, progress, progress.get_fraction() + fraction, progress_text)
        bectl.mount_be('pkgbase-upgrade', '/tmp/pkgbase-upgrade')
        progress_text = _("Boot environment mounted to /tmp/pkgbase-upgrade")
        GLib.idle_add(self.update_progress, progress, progress.get_fraction() + fraction, progress_text)
        sleep(1)
        progress_text = _("Removing os-generic packages from boot environment")
        GLib.idle_add(self.update_progress, progress, progress.get_fraction() + fraction, progress_text)
        assert remove_os_generic('/tmp/pkgbase-upgrade').returncode == 0
        progress_text = _("os-generic packages are removed from boot environment")
        GLib.idle_add(self.update_progress, progress, progress.get_fraction() + fraction, progress_text)
        sleep(1)
        progress_text = _("Installing PGKBASE in the boot environment")
        GLib.idle_add(self.update_progress, progress, progress.get_fraction() + fraction, progress_text)
        assert install_ghostbsd_pkgbase('/tmp/pkgbase-upgrade').returncode == 0
        progress_text = _("PGKBASE installed in the boot environment")
        GLib.idle_add(self.update_progress, progress, progress.get_fraction() + fraction, progress_text)
        sleep(1)
        progress_text = _("Restoring vital files")
        GLib.idle_add(self.update_progress, progress, progress.get_fraction() + fraction, progress_text)
        assert restore_vital_files('/tmp/pkgbase-upgrade')
        progress_text = _("Vital files restored")
        GLib.idle_add(self.update_progress, progress, progress.get_fraction() + fraction, progress_text)
        sleep(1)
        progress_text = _("Unmounting boot environment pkgbase-upgrade")
        GLib.idle_add(self.update_progress, progress, progress.get_fraction() + fraction, progress_text)
        bectl.umount_be('pkgbase-upgrade')
        progress_text = _("Boot environment unmounted")
        GLib.idle_add(self.update_progress, progress, progress.get_fraction() + fraction, progress_text)
        sleep(1)
        progress_text = _("Activating pkgbase-upgrade boot environment")
        GLib.idle_add(self.update_progress, progress, progress.get_fraction() + fraction, progress_text)
        bectl.activate_be('pkgbase-upgrade')
        progress_text = _("Activating pkgbase-upgrade boot environment completed")
        GLib.idle_add(self.update_progress, progress, progress.get_fraction() + fraction, progress_text)
        sleep(1)
        progress_text = _("Remove temporary package configuration")
        GLib.idle_add(self.update_progress, progress, progress.get_fraction() + fraction, progress_text)
        assert remove_package_config().returncode == 0
        progress_text = _("Temporary package configuration removed")
        GLib.idle_add(self.update_progress, progress, progress.get_fraction() + fraction, progress_text)
        sleep(1)
        self.stop_tread()

    def stop_tread(self):
        self.win.hide()
        self.thr.join()
        RestartSystem()


class InstallUpdate:
    """
    The class for the window that is displayed the progress of the update.
    """
    def close_application(self, widget, data):
        if updating():
            unlock_update_station()
        Gtk.main_quit()

    def __init__(self):
        """
        The constructor for the InstallUpdate class.
        """
        self.win = Gtk.Window()
        self.win.connect("delete-event", self.close_application)
        self.win.set_size_request(500, 75)
        self.win.set_resizable(False)
        self.win.set_title(_("Installing Update"))
        self.win.set_border_width(0)
        self.win.set_position(Gtk.WindowPosition.CENTER)
        self.win.set_default_icon_name('system-software-update')
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        self.win.add(box1)
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        self.pbar = Gtk.ProgressBar()
        self.pbar.set_show_text(True)
        self.pbar.set_fraction(0.0)
        # self.pbar.set_size_request(-1, 20)
        box2.pack_start(self.pbar, False, False, 0)
        self.win.show_all()
        self.thr = threading.Thread(target=self.read_output, args=[self.pbar], daemon=True)
        self.thr.start()

    def update_progress(self, progress, fraction, text):
        """
        Function that updates the progress bar.
        :param progress: The progress bar.
        :param fraction: The fraction to add.
        :param text: The text to display.
        """
        progress.set_fraction(fraction)
        progress.set_text(text)

    def read_output(self, progress):
        """
        Function that reads the output of the update to update the progress bar.
        :param progress: The progress bar.
        """
        fail = False
        update_pkg = False
        option = ''
        packages = ''
        env = f'env ABI={Data.new_abi} ' if Data.major_upgrade else ''
        need_reboot_packages = set(json.loads(open(f'{lib_path}/need_reboot.json').read()))
        upgrade_packages = set(re.split(": | ", " ".join(Data.packages_dictionary['upgrade'])))
        reboot = bool(need_reboot_packages.intersection(upgrade_packages))
        if len(Data.packages_dictionary['upgrade']) == 1 and 'pkg:' in Data.packages_dictionary['upgrade'][0]:
            update_pkg = True
            packages = ' pkg'
            Data.second_update = True
        else:
            Data.second_update = False
        if Data.kernel_upgrade:
            option = 'f'
        howmany = (Data.total_packages * 4) + 20
        fraction = 1.0 / howmany
        if Data.backup:
            today = datetime.datetime.now().strftime("%Y-%m-%d")
            txt = _("Cleaning old boot environment")
            GLib.idle_add(self.update_progress, progress, fraction, txt)
            for be in bectl.get_be_list():
                if 'backup' in be and today not in be and 'NR' not in be:
                    bectl.destroy_be(be.split()[0])
            backup_name = datetime.datetime.now().strftime(f"{distro.version()}-backup-%Y-%m-%d-%H-%M")
            txt = _("Creating boot environment")
            txt += f" {backup_name}"
            GLib.idle_add(self.update_progress, progress, fraction, txt)
            bectl.create_be(new_be_name=backup_name)
            sleep(1)
        if Data.major_upgrade:
            txt = _("Fetching package updates")
            new_val = progress.get_fraction() + fraction
            GLib.idle_add(self.update_progress, progress, new_val, txt)
            fetch = Popen(
                f'{env}env IGNORE_OSVERSION=yes ASSUME_ALWAYS_YES=yes pkg bootstrap -f',
                shell=True,
                stdout=PIPE,
                stderr=PIPE,
                close_fds=True,
                universal_newlines=True
            )
            fetch_text = ""
            while True:
                stdout_line = fetch.stdout.readline()
                if fetch.poll() is not None:
                    break
                fetch_text += stdout_line
                new_val = progress.get_fraction() + fraction
                GLib.idle_add(self.update_progress, progress, new_val,
                              stdout_line.strip())
            if fetch.returncode != 0:
                stderr_line = fetch.stderr.read()
                fetch_text += stderr_line
                update_fail = open(f'{home}/update.failed', 'w')
                update_fail.writelines(fetch_text)
                update_fail.close()
                fail = True
                GLib.idle_add(self.win.destroy)
                GLib.idle_add(self.stop_tread, fail, update_pkg, reboot)
                return
        txt = _("Fetching package updates")
        new_val = progress.get_fraction() + fraction
        GLib.idle_add(self.update_progress, progress, new_val, txt)
        sleep(1)
        fetch = Popen(
            f'{env}pkg-static upgrade -Fy{option}{packages}',
            shell=True,
            stdout=PIPE,
            stderr=PIPE,
            close_fds=True,
            universal_newlines=True
        )
        fetch_text = ""
        while True:
            stdout_line = fetch.stdout.readline()
            if fetch.poll() is not None:
                break
            fetch_text += stdout_line
            new_val = progress.get_fraction() + fraction
            GLib.idle_add(self.update_progress, progress, new_val,
                          stdout_line.strip())
        if fetch.returncode != 0:
            stderr_line = fetch.stderr.read()
            fetch_text += stderr_line
            update_fail = open(f'{home}/update.failed', 'w')
            update_fail.writelines(fetch_text)
            update_fail.close()
            fail = True
        else:
            new_val = progress.get_fraction() + fraction
            txt = _("Package updates downloaded")
            GLib.idle_add(self.update_progress, progress, new_val, txt)
            sleep(1)
            new_val = progress.get_fraction() + fraction
            txt = _("Installing package updates")
            GLib.idle_add(self.update_progress, progress, new_val, txt)
            sleep(1)
            while True:
                install = Popen(
                    f'{env}pkg-static upgrade -y{option}{packages}',
                    shell=True,
                    stdout=PIPE,
                    stderr=PIPE,
                    close_fds=True,
                    universal_newlines=True
                )
                install_text = ""
                while True:
                    stdout_line = install.stdout.readline()
                    if install.poll() is not None:
                        break
                    install_text += stdout_line
                    new_val = progress.get_fraction() + fraction
                    GLib.idle_add(self.update_progress, progress, new_val,
                                  stdout_line.strip())
                if install.returncode == 3:
                    stderr_line = install.stderr.readline()
                    if 'Fail to create temporary file' in stderr_line:
                        raw_line = install_text.splitlines()[-2]
                        failed_package = raw_line.split()[2].replace(':', '')
                        pkg_rquery = run(
                            f'{env}pkg-static rquery -x "%n" "{failed_package}"',
                            shell=True,
                            stdout=PIPE,
                            stderr=PIPE,
                            universal_newlines=True
                        )
                        package_name = pkg_rquery.stdout.strip()
                        reinstall = Popen(
                            f'{env}pkg-static delete -y {package_name} ;'
                            f'{env}pkg-static install -y {package_name}',
                            shell=True,
                            stdout=PIPE,
                            stderr=PIPE,
                            close_fds=True,
                            universal_newlines=True
                        )
                        reinstall_text = ""
                        while True:
                            stdout_line = reinstall.stdout.readline()
                            if reinstall.poll() is not None:
                                break
                            reinstall_text += stdout_line
                            new_val = progress.get_fraction() + fraction
                            GLib.idle_add(self.update_progress, progress,
                                          new_val, stdout_line.strip())
                        if reinstall.returncode != 0:
                            reinstall_text += reinstall.stderr.readline()
                            update_fail = open(f'{home}/update.failed', 'w')
                            update_fail.writelines(reinstall_text)
                            update_fail.close()
                            fail = True
                            break
                        else:
                            new_val = progress.get_fraction() + fraction
                            txt = _("Reinstalling")
                            txt += f" {failed_package} "
                            txt += _("completed")
                            GLib.idle_add(self.update_progress, progress, new_val, txt)
                            sleep(1)
                elif install.returncode != 0:
                    stderr_line = install.stderr.readline()
                    install_text += stderr_line
                    update_fail = open(f'{home}/update.failed', 'w')
                    update_fail.writelines(install_text)
                    update_fail.close()
                    fail = True
                    break
                else:
                    new_val = progress.get_fraction() + fraction
                    txt = _("Software packages upgrade completed")
                    GLib.idle_add(self.update_progress, progress, new_val, txt)
                    sleep(1)
                    break
        GLib.idle_add(self.win.destroy)
        GLib.idle_add(self.stop_tread, fail, update_pkg, reboot)

    def stop_tread(self, fail: bool, update_pkg: bool, reboot: bool):
        """
        The function to stop the thread.
        :param fail: True if update failed.
        :param update_pkg: True if update pkg was updated first.
        :param reboot: True if system needs to be rebooted after update completed.
        """
        self.thr.join()
        if updating():
            unlock_update_station()
        if fail is True:
            Data.update_started = False
            Data.stop_pkg_refreshing = False
            FailedUpdate()
        else:
            if update_pkg is True and check_for_update() is True:
                Data.packages_dictionary = get_pkg_upgrade_data()
                StartCheckUpdate()
            else:
                Data.update_started = False
                Data.stop_pkg_refreshing = False
                if reboot is True:
                    RestartSystem()
                else:
                    UpdateCompleted()


class FailedUpdate:
    """
    FailedUpdate class for failed update window.
    """

    def get_detail(self, widget):
        Popen(f'sudo -u {username} xdg-open {home}/update.failed', shell=True)

    def on_close(self, widget):
        """
        The function to close the window.
        :param widget: The window widget.
        """
        if Data.close_session is True:
            Gtk.main_quit()
        else:
            self.window.destroy()

    def __init__(self):
        """
        The constructor of the FailedUpdate class.
        """
        self.window = Gtk.Window()
        self.window.set_position(Gtk.WindowPosition.CENTER)
        # self.window.set_border_width(8)
        self.window.connect("destroy", self.on_close)
        self.window.set_title(_("Update Failed"))
        self.window.set_default_icon_name('system-software-update')
        v_box = Gtk.VBox(homogeneous=False, spacing=0)
        self.window.add(v_box)
        v_box.show()
        label = Gtk.Label()
        failed_text = _("""Press "Detail" to get information about the failure.
        Get help at https://forums.ghostbsd.org.""")
        label.set_markup(failed_text)
        v_box.set_border_width(5)
        v_box.pack_start(label, False, False, 5)
        hBox = Gtk.HBox(homogeneous=False, spacing=0)
        # hBox.set_border_width(5)
        v_box.pack_start(hBox, False, True, 5)
        hBox.show()
        restart = Gtk.Button(label=_("Detail"))
        restart.connect("clicked", self.get_detail)
        continue_button = Gtk.Button(label=_("Close"))
        continue_button.connect("clicked", self.on_close)
        hBox.pack_end(continue_button, False, False, 5)
        hBox.pack_end(restart, False, False, 5)
        self.window.show_all()


class RestartSystem:
    """
    RestartSystem class for restarting system window.
    """
    def on_reboot(self, widget):
        """
        The function to reboot the system.
        :param widget: The window widget.
        """
        Popen('shutdown -r now', shell=True)
        Gtk.main_quit()

    def on_close(self, widget):
        """
        The function to close the window.
        :param widget: The window widget.
        """
        if Data.close_session is True:
            Gtk.main_quit()
        else:
            self.window.destroy()

    def __init__(self):
        """
        The constructor of the RestartSystem class.
        """
        self.window = Gtk.Window()
        self.window.set_position(Gtk.WindowPosition.CENTER)
        # self.window.set_border_width(8)
        self.window.connect("destroy", self.on_close)
        self.window.set_title(_("Update Completed"))
        self.window.set_default_icon_name('system-software-update')
        vBox = Gtk.VBox(homogeneous=False, spacing=0)
        self.window.add(vBox)
        vBox.show()
        reboot_text = _("The computer needs to restart to run on the updated software.")
        label = Gtk.Label(label=reboot_text)
        vBox.set_border_width(5)
        vBox.pack_start(label, False, False, 5)
        hBox = Gtk.HBox(homogeneous=False, spacing=0)
        # hBox.set_border_width(5)
        vBox.pack_start(hBox, False, True, 5)
        hBox.show()
        restart = Gtk.Button(label=_("Restart Now"))
        restart.connect("clicked", self.on_reboot)
        continue_button = Gtk.Button(label=_("Restart Later"))
        continue_button.connect("clicked", self.on_close)
        hBox.pack_end(restart, False, False, 5)
        hBox.pack_end(continue_button, False, False, 5)
        self.window.show_all()


class UpdateCompleted:
    """
    Class for update completed window.
    """

    def on_close(self, widget: Gtk.Widget):
        """
        The function to close the window.
        :param widget: The window widget.
        """
        if Data.close_session is True:
            Gtk.main_quit()
        else:
            self.window.destroy()

    def __init__(self):
        """
        The constructor of the UpdateCompleted class.
        """
        self.window = Gtk.Window()
        self.window.set_position(Gtk.WindowPosition.CENTER)
        self.window.connect("destroy", self.on_close)
        self.window.set_title(_("Update Completed"))
        self.window.set_default_icon_name('system-software-update')
        v_box = Gtk.VBox(homogeneous=False, spacing=0)
        self.window.add(v_box)
        v_box.show()
        label = Gtk.Label(label=_("""All software on this system is up to date."""))
        v_box.set_border_width(5)
        v_box.pack_start(label, False, False, 5)
        hBox = Gtk.HBox(homogeneous=False, spacing=0)
        # hBox.set_border_width(5)
        v_box.pack_start(hBox, False, True, 5)
        hBox.show()
        close_button = Gtk.Button(label=_("Close"))
        close_button.connect("clicked", self.on_close)
        hBox.pack_end(close_button, False, False, 5)
        self.window.show_all()


class NoUpdateAvailable(object):
    """
    Class for no update available window.
    """

    def __init__(self):
        """
        The constructor of the NoUpdateAvailable class.
        """
        window = Gtk.Window()
        window.set_position(Gtk.WindowPosition.CENTER)
        window.set_border_width(8)
        window.connect("destroy", Gtk.main_quit)
        window.set_title(_("No Update Available"))
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        window.add(box1)
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        label = Gtk.Label(label=_("No update available. This system is up "
                          "to date."))
        box2.pack_start(label, False, False, 0)
        box2 = Gtk.HBox(homogeneous=False, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, True, 0)
        box2.show()
        ok_button = Gtk.Button(label=_("Close"))
        ok_button.connect("clicked", Gtk.main_quit)
        box2.pack_end(ok_button, False, False, 0)
        window.show_all()


class StartCheckUpdate:
    """
    Class for start check for update window.
    """
    def close_application(self, widget: Gtk.Widget):
        """
        The function to close the window.
        :param widget: The window widget.
        """
        if updating():
            unlock_update_station()
        Gtk.main_quit()

    def __init__(self):
        """
        The constructor of the StartCheckUpdate class.
        """
        self.win = Gtk.Window()
        self.win.connect("delete-event", self.close_application)
        self.win.set_size_request(500, 75)
        self.win.set_resizable(False)
        self.win.set_title(_("Looking For Updates"))
        self.win.set_border_width(0)
        self.win.set_position(Gtk.WindowPosition.CENTER)
        self.win.set_default_icon_name('system-software-update')
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        self.win.add(box1)
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        self.pbar = Gtk.ProgressBar()
        self.pbar.set_show_text(True)
        self.pbar.set_fraction(0.0)
        box2.pack_start(self.pbar, False, False, 0)
        self.win.show_all()
        self.thr = threading.Thread(
            target=self.check_for_update,
            args=[self.pbar],
            daemon=True
        )
        self.thr.start()

    def update_progress(self, progress: Gtk.ProgressBar, text: str):
        """
        The function to update the progress bar.
        :param progress: The progress bar.
        :param text: the text to be displayed on the progress bar.
        """
        progress.set_text(text)
        fraction = progress.get_fraction() + 0.2
        progress.set_fraction(fraction)

    def check_for_update(self, progress: Gtk.ProgressBar):
        """
        The function to check for update and update the progress bar.
        :param progress: The progress bar.
        """
        GLib.idle_add(self.update_progress, progress,
                      _('Checking if the repository is online'))
        sleep(1)
        if network_stat() == 'UP' and repo_online() is True:
            GLib.idle_add(self.update_progress, progress,
                          _('The repository is online'))
            sleep(1)
            if repository_is_syncing() is True:
                GLib.idle_add(self.update_progress, progress,
                              _('The mirror is Syncing'))
                GLib.idle_add(self.stop_tread, MirrorSyncing)
            else:
                if updating():
                    GLib.idle_add(self.update_progress, progress,
                                  _('Updates are already running'))
                    GLib.idle_add(self.stop_tread, UpdateStationOpen)
                else:
                    GLib.idle_add(self.update_progress, progress,
                                  _('Checking for updates'))
                    update_available = check_for_update()
                    if update_available:
                        GLib.idle_add(self.update_progress, progress,
                                      _('Getting the list of packages'))
                        Data.packages_dictionary = get_pkg_upgrade_data()
                        look_update_station()
                        GLib.idle_add(self.update_progress, progress,
                                      _('Open the update window'))
                        GLib.idle_add(self.stop_tread, UpdateWindow)
                    elif not update_available and update_available is not None:
                        GLib.idle_add(self.update_progress, progress,
                                      _('No update found'))
                        GLib.idle_add(self.stop_tread, NoUpdateAvailable)
                    else:
                        GLib.idle_add(self.stop_tread, SomethingIsWrong)
        else:
            GLib.idle_add(self.update_progress, progress,
                          _('The Mirror is unreachable'))
            GLib.idle_add(self.stop_tread, ServerUnreachable)

    def stop_tread(self, start_window: object):
        """
        The function to stop the thread.
        :param start_window: The start window object.
        """
        start_window()
        self.win.hide()
        self.thr.join()


class UpdateStationOpen(object):
    """
    Class for update station already started window.
    """
    def on_close(self, widget):
        """
        The function to close the window.
        :param widget: The window widget.
        """
        if Data.close_session is True:
            Gtk.main_quit()
        else:
            self.window.destroy()

    def __init__(self):
        """
        The constructor of the UpdateStationOpen class.
        """
        self.window = Gtk.Window()
        self.window.set_position(Gtk.WindowPosition.CENTER)
        self.window.set_border_width(8)
        self.window.connect("destroy", self.on_close)
        self.window.set_title(_("Update Station already started"))
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        self.window.add(box1)
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        label = Gtk.Label(label=_("Update Station already open."))
        box2.pack_start(label, False, False, 0)
        box2 = Gtk.HBox(homogeneous=False, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, True, 0)
        box2.show()
        ok_button = Gtk.Button(label=_("Close"))
        ok_button.connect("clicked", self.on_close)
        box2.pack_end(ok_button, False, False, 0)
        self.window.show_all()


class MirrorSyncing(object):
    """
    Class for the mirror is syncing warning window.
    """

    def __init__(self):
        """
        The constructor of the MirrorSyncing class.
        """
        window = Gtk.Window()
        window.set_position(Gtk.WindowPosition.CENTER)
        window.set_border_width(8)
        window.connect("destroy", Gtk.main_quit)
        window.set_title(_("Server Unreachable"))
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        window.add(box1)
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        label = Gtk.Label(label=_("Packages mirrors are syncing with new "
                          "packages"))
        box2.pack_start(label, False, False, 0)
        box2 = Gtk.HBox(homogeneous=False, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, True, 0)
        box2.show()
        ok_button = Gtk.Button(label=_("Close"))
        ok_button.connect("clicked", Gtk.main_quit)
        box2.pack_end(ok_button, False, False, 0)
        window.show_all()


class ServerUnreachable(object):
    """
    Class for the server unreachable warning window.
    """

    def __init__(self):
        """
        The constructor of the ServerUnreachable class.
        """
        window = Gtk.Window()
        window.set_position(Gtk.WindowPosition.CENTER)
        window.set_border_width(8)
        window.connect("destroy", Gtk.main_quit)
        window.set_title(_("Server Unreachable"))
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        window.add(box1)
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        label = Gtk.Label(label=_("The server is unreachable. Your internet "
                          "could\nbe down or software package server is down."))
        box2.pack_start(label, False, False, 0)
        box2 = Gtk.HBox(homogeneous=False, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, True, 0)
        box2.show()
        ok_button = Gtk.Button(label=_("Close"))
        ok_button.connect("clicked", Gtk.main_quit)
        box2.pack_end(ok_button, False, False, 0)
        window.show_all()


class SomethingIsWrong(object):
    """
    Class for the something is wrong warning window.
    """

    def __init__(self):
        """
        The constructor of the SomethingIsWrong class.
        """
        window = Gtk.Window()
        window.set_position(Gtk.WindowPosition.CENTER)
        window.set_border_width(8)
        window.connect("destroy", Gtk.main_quit)
        window.set_title(_("Something Is Wrong"))
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        window.add(box1)
        box1.show()
        box2 = Gtk.VBox(homogeneous=False, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        box2.show()
        label = Gtk.Label(label=_(
                          "If you see this message it means that "
                          "something is wrong.\n Please look at pkg upgrade "
                          "output."))
        box2.pack_start(label, False, False, 0)
        box2 = Gtk.HBox(homogeneous=False, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, True, 0)
        box2.show()
        ok_button = Gtk.Button(label=_("Close"))
        ok_button.connect("clicked", Gtk.main_quit)
        box2.pack_end(ok_button, False, False, 0)
        window.show_all()


class NotRoot(Gtk.Window):
    """
    Class for the user is not root warning window.
    """
    def __init__(self):
        """
        The constructor of the NotRoot class.
        """
        Gtk.Window.__init__(self)
        self.set_title(_("Software Station"))
        self.connect("delete-event", Gtk.main_quit)
        self.set_size_request(200, 80)
        box1 = Gtk.VBox(homogeneous=False, spacing=0)
        self.add(box1)
        box1.show()
        label = Gtk.Label(label=_('You need to be root'))
        box1.pack_start(label, True, True, 0)
        hBox = Gtk.HBox(homogeneous=False, spacing=0)
        hBox.show()
        box1.pack_end(hBox, False, False, 5)
        ok_button = Gtk.Button()
        ok_button.set_label(_("OK"))
        apply_img = Gtk.Image()
        apply_img.set_from_icon_name('gtk-ok')
        ok_button.set_image(apply_img)
        ok_button.connect("clicked", Gtk.main_quit)
        hBox.pack_end(ok_button, False, False, 5)
        self.show_all()


arg = sys.argv
UsageMSG = f"""
Usage for {arg[0]}:

Available Commands:

check-now       - Look for update now

"""


if os.geteuid() == 0:
    if len(arg) == 1:
        if socket.gethostname() != 'livecd':
            Data.close_session = False
            tray = TrayIcon()
            tray.threading_update()
        else:
            exit()
    elif len(arg) == 2 and arg[1] == "check-now":
        Data.close_session = True
        StartCheckUpdate()
    else:
        print(UsageMSG)
        sys.exit(0)
else:
    NotRoot()
Gtk.main()
