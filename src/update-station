#!/usr/bin/env python3.11
"""This is the main file for the update-station application"""

import bectl
import datetime
import getpass
import gi
import json
import os
import gettext
import re
import socket
import sys
import threading
import distro
from subprocess import Popen, PIPE, run
from time import sleep
from update_data import Data
from updateHandler import (
    check_for_update,
    get_pkg_upgrade_data,
    network_stat,
    repo_online,
    look_update_station,
    unlock_update_station,
    updating,
    repository_is_syncing,
    is_major_upgrade_available,
    get_abi_upgrade,
    get_current_abi,
    find_if_os_generic_exists,
    remove_os_generic,
    install_ghostbsd_pkgbase,
    set_package_base_config_file,
    restore_vital_files
)

gi.require_version('Gtk', '3.0')
gi.require_version('Notify', '0.7')
from gi.repository import Gtk, GLib, Notify

gettext.bindtextdomain('update-station', '/usr/local/share/locale')
gettext.textdomain('update-station')
_ = gettext.gettext

lib_path: str = f'{sys.prefix}/lib/update-station'

__VERSION__ = '5.1'

username = os.environ.get('SUDO_USER') if 'SUDO_USER' in os.environ else getpass.getuser()
home = os.path.expanduser('~')


class UpdateWindow:
    """
    Class that creates the main window to see update list and start the update process.
    """
    def delete_event(self, widget: Gtk.Widget, event) -> bool:
        """
        Function that handles the delete event when the window is closed.
        :param widget: The widget that triggered the delete event.
        """
        if Data.close_session is True:
            if updating():
                unlock_update_station()
            Gtk.main_quit()
        else:
            self.window.destroy()
            if Data.update_started is False:
                Data.stop_pkg_refreshing = False
                if updating():
                    unlock_update_station()
                tray.tray_icon().set_visible(True)
        return True

    def start_update(self, widget):
        """
        Function that starts the update process.
        :param widget: The widget that triggered the start update event.
        """
        Data.update_started = True
        InstallUpdate()
        self.window.hide()

    def if_backup(self, widget):
        """
        Function that handles the backup checkbox.
        :param widget: The widget that triggered the checkbox event.
        """
        Data.backup = widget.get_active()

    def create_bbox(self):
        """
        Function that creates the button box.
        :return: The button box.
        """
        table = Gtk.Grid()
        backup_checkbox = Gtk.CheckButton(label=_("Create boot environment backup"))
        table.attach(backup_checkbox, 0, 0, 1, 1)
        backup_checkbox.connect("toggled", self.if_backup)
        if bectl.is_file_system_zfs() and Data.second_update is False:
            backup_checkbox.set_active(True)
            backup_checkbox.set_sensitive(True)
            Data.backup = True
        else:
            backup_checkbox.set_active(False)
            backup_checkbox.set_sensitive(False)
            Data.backup = False

        close_button = Gtk.Button(label=_("Close"))
        close_button.set_image(Gtk.Image(icon_name='window-close'))
        table.attach(close_button, 3, 0, 1, 1)
        close_button.connect("clicked", self.delete_event)

        install_button = Gtk.Button(label=_("Install update"))
        table.attach(install_button, 4, 0, 1, 1)
        install_button.connect("clicked", self.start_update)
        return table

    def __init__(self):
        """
        The constructor for the UpdateWindow class.
        """
        self.window = Gtk.Window()
        self.window.connect("destroy", self.delete_event)
        self.window.set_size_request(700, 400)
        self.window.set_resizable(False)
        self.window.set_title(_("Update Manager"))
        self.window.set_border_width(0)
        self.window.set_position(Gtk.WindowPosition.CENTER)
        self.window.set_default_icon_name('system-software-update')
        box1 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.window.add(box1)
        box2 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        box2.set_border_width(20)
        box1.pack_start(box2, True, True, 0)
        # Title
        title_text = _("Updates available!")
        update_title_label = Gtk.Label()
        update_title_label.set_markup(f"<b><span size='large'>{title_text}</span></b>")
        box2.pack_start(update_title_label, False, False, 0)

        self.tree_store = Gtk.TreeStore(str, bool)
        sw = Gtk.ScrolledWindow()
        sw.set_shadow_type(Gtk.ShadowType.ETCHED_IN)
        sw.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        self.view = Gtk.TreeView(model=self.store())
        self.renderer = Gtk.CellRendererText()
        self.column0 = Gtk.TreeViewColumn("Name", self.renderer, text=0)
        self.view.append_column(self.column0)
        self.view.set_headers_visible(False)
        sw.add(self.view)
        box2.pack_start(sw, True, True, 10)

        box2 = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, False, 5)
        box2.pack_start(self.create_bbox(), True, True, 10)
        self.window.show_all()

    def store(self):
        """
        Function that creates the store for the list of package in the treeview.
        :return: The store for the list of package to be updated.
        """
        self.tree_store.clear()
        r_num = 0
        u_num = 0
        i_num = 0
        ri_num = 0
        if bool(Data.packages_dictionary['remove']):
            r_num = len(Data.packages_dictionary['remove'])
            message = _('Installed packages to be REMOVED:')
            message += f' {r_num}'
            r_pinter = self.tree_store.append(None, (message, True))
            for line in Data.packages_dictionary['remove']:
                self.tree_store.append(r_pinter, (line, True))
        if bool(Data.packages_dictionary['upgrade']):
            u_num = len(Data.packages_dictionary['upgrade'])
            message = _('Installed packages to be UPGRADED')
            message += f' {u_num}'
            u_pinter = self.tree_store.append(None, (message, True))
            for line in Data.packages_dictionary['upgrade']:
                self.tree_store.append(u_pinter, (line, True))
        if bool(Data.packages_dictionary['install']):
            i_num = len(Data.packages_dictionary['install'])
            message = _('New packages to be INSTALLED:')
            message += f' {i_num}'
            i_pinter = self.tree_store.append(None, (message, True))
            for line in Data.packages_dictionary['install']:
                self.tree_store.append(i_pinter, (line, True))
        if bool(Data.packages_dictionary['reinstall']):
            ri_num = len(Data.packages_dictionary['reinstall'])
            message = _('Installed packages to be REINSTALLED:')
            message += f' {ri_num}'
            ri_pinter = self.tree_store.append(None, (message, True))
            for line in Data.packages_dictionary['reinstall']:
                self.tree_store.append(ri_pinter, (line, True))
        Data.total_packages = r_num + u_num + i_num + ri_num
        return self.tree_store

    def display(self, model: Gtk.TreeStore) -> Gtk.TreeView:
        """
        Function that creates the treeview.

        :param model: The store for the list of package to be updated.
        :return: The treeview.
        """
        self.view = Gtk.TreeView(model=model)
        self.renderer = Gtk.CellRendererText()
        self.column0 = Gtk.TreeViewColumn("Name", self.renderer, text=0)
        self.view.append_column(self.column0)
        self.view.set_headers_visible(False)
        return self.view


class UpdateNotifier:
    """
    Class that creates the notification for the update.
    """

    def __init__(self):
        """
        The constructor for the UpdateNotifier class.
        """
        self.notification = None
        Notify.init('Test')
        self.msg = _("Software updates are now available.")
        self.timeout = 10000  # 10 seconds

    def notify(self):
        """
        Function that creates the notification for the update.
        """
        if Data.major_upgrade is True:
            self.msg = _("Major system version upgrade is now available.")
        elif Data.kernel_upgrade is True:
            self.msg = _("System and software updates are now available.")
        self.notification = Notify.Notification.new(
            summary=_('Update Available'),
            body=self.msg,
            icon='system-software-update'
        )
        self.notification.add_action('clicked', 'Start Upgrade', self.on_activated)
        self.notification.show()

    def on_activated(self, notification, action_name):
        """
        Function that starts the upgrade.
        :param notification: The notification widget.
        :param action_name: The name of the action.
        """
        if Data.major_upgrade is True:
            MajorUpgradeWindow()
        else:
            StartCheckUpdate()
        notification.close()
        GLib.idle_add(tray.tray_icon().set_visible, False)


class MajorUpgradeWindow(Gtk.Window):
    """
    Class that creates the window for the major upgrade.
    """

    def __init__(self):
        """
        The constructor for the MajorUpgradeWindow class.
        """
        Gtk.Window.__init__(self, title=_("Major version upgrade"))
        self.connect("destroy", Gtk.main_quit)
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        vbox.set_border_width(10)
        self.add(vbox)

        label = Gtk.Label(
            label=_(f"Would you like to upgrade from {Data.current_abi} to {Data.new_abi}?"
                    "\n\nIf you select No, the upgrade will be skipped until the next boot.")
        )
        vbox.pack_start(label, True, True, 5)
        hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        vbox.pack_start(hbox, False, False, 0)
        button1 = Gtk.Button(label="Yes")
        button1.connect("clicked", self.on_clicked)
        hbox.pack_end(button1, True, True, 0)

        button2 = Gtk.Button(label="No")
        button2.connect("clicked", self.on_clicked)
        hbox.pack_end(button2, True, True, 0)
        self.show_all()

    def on_clicked(self, widget):
        """
        Function that starts the upgrade.
        :param widget: The widget that was clicked.
        """
        if widget.get_label() == "Yes":
            Data.major_upgrade = True
            Data.do_not_upgrade = False
            StartCheckUpdate()
        else:
            Data.major_upgrade = False
            Data.do_not_upgrade = True
        self.hide()


class TrayIcon:
    """
    The class for the tray icon.
    """

    def tray_icon(self):
        return self.status_icon

    def __init__(self):
        """
        The constructor for the TrayIcon class.
        """
        self.status_icon = Gtk.StatusIcon()
        self.status_icon.set_tooltip_text('Update Available')
        self.menu = Gtk.Menu()
        self.menu.show_all()
        self.status_icon.connect("activate", self.left_click)
        self.status_icon.connect('popup-menu', self.icon_clicked)
        self.status_icon.set_visible(False)
        self.status_icon.set_from_icon_name('system-software-update')

    def nm_menu(self):
        """
        Function that creates the menu for the tray icon.
        :return: The menu.
        """
        self.menu = Gtk.Menu()
        open_update = Gtk.MenuItem(label=_("Open Update"))
        open_update.connect("activate", self.left_click)
        close_item = Gtk.MenuItem(label=_("Close"))
        close_item.connect("activate", Gtk.main_quit)
        self.menu.append(open_update)
        self.menu.append(close_item)
        self.menu.show_all()
        return self.menu

    def left_click(self, status_icon: Gtk.StatusIcon):
        """
        Function that is called when the user left-clicks on the tray icon.
        :param status_icon: The status icon.
        """
        if updating():
            UpdateStationOpen()
        else:
            Data.stop_pkg_refreshing = True
            if Data.major_upgrade is True:
                MajorUpgradeWindow()
            else:
                StartCheckUpdate()
        status_icon.set_visible(False)

    def icon_clicked(self, status_icon, button, time):
        """
        Function that is called when the user right-clicks on the tray icon.
        :param status_icon: The status icon.
        :param button: The button.
        :param time: The time.
        """
        position = Gtk.StatusIcon.position_menu
        self.nm_menu().popup(None, None, position, status_icon, button, time)

    def update_tray(self):
        """
        Function that updates the tray icon.
        """
        if find_if_os_generic_exists():
            UpgradeToPKGBase()
        if check_for_update():
            GLib.idle_add(self.status_icon.set_visible, True)
            notifier = UpdateNotifier()
            notifier.notify()
        elif is_major_upgrade_available() and Data.do_not_upgrade is False:
            Data.major_upgrade = True
            GLib.idle_add(self.status_icon.set_visible, True)
            Data.current_abi = get_current_abi()
            Data.new_abi = get_abi_upgrade()
            notifier = UpdateNotifier()
            notifier.notify()
        else:
            GLib.idle_add(self.status_icon.set_visible, False)

    def threading_update(self):
        """
        Function that creates a thread that checks for updates.
        """
        if updating():
            unlock_update_station()
        thr = threading.Thread(target=self.check, daemon=True)
        thr.start()

    def check(self):
        """
        Function that checks for updates.
        """
        while True:
            sleep(120)
            if not repository_is_syncing():
                if not Data.stop_pkg_refreshing:
                    if not updating():
                        GLib.idle_add(self.update_tray)
                    else:
                        GLib.idle_add(self.status_icon.set_visible, False)
            # Wait for an hour to look for update
            sleep(600)


class UpgradeToPKGBase(Gtk.Window):
    def __init__(self):
        Gtk.Window.__init__(self, title=_("Upgrade to PKGBASE"))
        self.connect("destroy", Gtk.main_quit)
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=5)
        vbox.set_border_width(10)
        self.add(vbox)
        label = Gtk.Label(label=_("Would you like to upgrade to PKGBASE?"))
        vbox.pack_start(label, True, True, 5)
        hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=5)
        vbox.pack_end(hbox, False, False, 0)
        button1 = Gtk.Button(label=_("Upgrade Now"))
        button1.connect("clicked", self.on_clicked)

    def on_clicked(self, widget):
        self.hide()
        UpgradePKGBASEProgress()


class UpgradePKGBASEProgress:
    """
    The class for the window that is displayed the progress of the update.
    """
    def close_application(self, widget, data):
        if updating():
            unlock_update_station()
        Gtk.main_quit()

    def __init__(self):
        """
        The constructor for the InstallUpdate class.
        """
        self.win = Gtk.Window()
        self.win.connect("delete-event", self.close_application)
        self.win.set_size_request(500, 75)
        self.win.set_resizable(False)
        self.win.set_title(_("Upgrading to PKGBASE"))
        self.win.set_border_width(0)
        self.win.set_position(Gtk.WindowPosition.CENTER)
        self.win.set_default_icon_name('system-software-update')
        box1 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.win.add(box1)
        box2 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        self.pbar = Gtk.ProgressBar()
        self.pbar.set_show_text(True)
        self.pbar.set_fraction(0.0)
        box2.pack_start(self.pbar, False, False, 0)
        self.win.show_all()
        self.thr = threading.Thread(
            target=self.read_output,
            args=[self.pbar],
            daemon=True
        )
        self.thr.start()

    def update_progress(self, progress, fraction, text):
        """
        Function that updates the progress bar.
        :param progress: The progress bar.
        :param fraction: The fraction to add.
        :param text: The text to display.
        """
        progress.set_fraction(fraction)
        progress.set_text(text)

    def read_output(self, progress):
        fraction = 1.0 / 16
        progress_text = _("Adding PKGBASE repository support")
        GLib.idle_add(self.update_progress, progress, fraction, progress_text)
        assert set_package_base_config_file().returncode == 0
        progress_text = _("Adding PKGBASE repository support completed")
        GLib.idle_add(self.update_progress, progress, fraction, progress_text)
        sleep(1)
        progress_text = _("Creating boot environment pkgbase-upgrade")
        GLib.idle_add(self.update_progress, progress, fraction, progress_text)
        bectl.create_be('pkgbase-upgrade')
        progress_text = _("Boot environment pkgbase-upgrade created")
        GLib.idle_add(self.update_progress, progress, fraction, progress_text)
        sleep(1)
        progress_text = _("Mounting boot environment pkgbase-upgrade")
        GLib.idle_add(self.update_progress, progress, fraction, progress_text)
        bectl.mount_be('pkgbase-upgrade', '/tmp/pkgbase-upgrade')
        progress_text = _("Boot environment mounted to /tmp/pkgbase-upgrade")
        GLib.idle_add(self.update_progress, progress, fraction, progress_text)
        sleep(1)
        progress_text = _("Removing os-generic packages from boot environment")
        GLib.idle_add(self.update_progress, progress, fraction, progress_text)
        assert remove_os_generic('/tmp/pkgbase-upgrade').returncode == 0
        progress_text = _("os-generic packages are removed from boot environment")
        GLib.idle_add(self.update_progress, progress, fraction, progress_text)
        sleep(1)
        progress_text = _("Installing PGKBASE in the boot environment")
        GLib.idle_add(self.update_progress, progress, fraction, progress_text)
        assert install_ghostbsd_pkgbase('/tmp/pkgbase-upgrade') == 0
        progress_text = _("PGKBASE installed in the boot environment")
        GLib.idle_add(self.update_progress, progress, fraction, progress_text)
        sleep(1)
        progress_text = _("Restoring vital files")
        GLib.idle_add(self.update_progress, progress, fraction, progress_text)
        assert restore_vital_files('/tmp/pkgbase-upgrade') == 0
        progress_text = _("Vital files restored")
        GLib.idle_add(self.update_progress, progress, fraction, progress_text)
        sleep(1)
        progress_text = _("Unmounting boot environment pkgbase-upgrade")
        GLib.idle_add(self.update_progress, progress, fraction, progress_text)
        bectl.umount_be('pkgbase-upgrade')
        progress_text = _("Boot environment unmounted")
        GLib.idle_add(self.update_progress, progress, fraction, progress_text)
        sleep(1)
        progress_text = _("Activating pkgbase-upgrade boot environment")
        GLib.idle_add(self.update_progress, progress, fraction, progress_text)
        bectl.activate_be('pkgbase-upgrade')
        progress_text = _("Activating pkgbase-upgrade boot environment completed")
        GLib.idle_add(self.update_progress, progress, fraction, progress_text)
        sleep(1)
        self.stop_tread()

    def stop_tread(self):
        self.win.hide()
        self.thr.join()


class InstallUpdate:
    """
    The class for the window that is displayed the progress of the update.
    """
    def close_application(self, widget, data):
        if updating():
            unlock_update_station()
        Gtk.main_quit()

    def __init__(self):
        """
        The constructor for the InstallUpdate class.
        """
        self.win = Gtk.Window()
        self.win.connect("delete-event", self.close_application)
        self.win.set_size_request(500, 75)
        self.win.set_resizable(False)
        self.win.set_title(_("Installing Update"))
        self.win.set_border_width(0)
        self.win.set_position(Gtk.WindowPosition.CENTER)
        self.win.set_default_icon_name('system-software-update')
        box1 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.win.add(box1)
        box2 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        self.pbar = Gtk.ProgressBar()
        self.pbar.set_show_text(True)
        self.pbar.set_fraction(0.0)
        box2.pack_start(self.pbar, False, False, 0)
        self.win.show_all()
        self.thr = threading.Thread(target=self.read_output, args=[self.pbar], daemon=True)
        self.thr.start()

    def update_progress(self, progress, fraction, text):
        """
        Function that updates the progress bar.
        :param progress: The progress bar.
        :param fraction: The fraction to add.
        :param text: The text to display.
        """
        progress.set_fraction(fraction)
        progress.set_text(text)

    def read_output(self, progress):
        """
        Function that reads the output of the update to update the progress bar.
        :param progress: The progress bar.
        """
        fail = False
        update_pkg = False
        option = ''
        packages = ''
        env = f'env ABI={Data.new_abi} ' if Data.major_upgrade else ''
        need_reboot_packages = set(json.loads(open(f'{lib_path}/need_reboot.json').read()))
        upgrade_packages = set(re.split(": | ", " ".join(Data.packages_dictionary['upgrade'])))
        reboot = bool(need_reboot_packages.intersection(upgrade_packages))
        if len(Data.packages_dictionary['upgrade']) == 1 and 'pkg:' in Data.packages_dictionary['upgrade'][0]:
            update_pkg = True
            packages = ' pkg'
            Data.second_update = True
        else:
            Data.second_update = False
        if Data.kernel_upgrade:
            option = 'f'
        howmany = (Data.total_packages * 4) + 20
        fraction = 1.0 / howmany
        if Data.backup:
            today = datetime.datetime.now().strftime("%Y-%m-%d")
            txt = _("Cleaning old boot environment")
            GLib.idle_add(self.update_progress, progress, fraction, txt)
            for be in bectl.get_be_list():
                if 'backup' in be and today not in be and 'NR' not in be:
                    bectl.destroy_be(be.split()[0])
            backup_name = datetime.datetime.now().strftime(f"{distro.version()}-backup-%Y-%m-%d-%H-%M")
            txt = _("Creating boot environment")
            txt += f" {backup_name}"
            GLib.idle_add(self.update_progress, progress, fraction, txt)
            bectl.create_be(new_be_name=backup_name)
            sleep(1)
        if Data.major_upgrade:
            txt = _("Fetching package updates")
            new_val = progress.get_fraction() + fraction
            GLib.idle_add(self.update_progress, progress, new_val, txt)
            fetch = Popen(
                f'{env}env IGNORE_OSVERSION=yes ASSUME_ALWAYS_YES=yes pkg bootstrap -f',
                shell=True,
                stdout=PIPE,
                stderr=PIPE,
                close_fds=True,
                universal_newlines=True
            )
            fetch_text = ""
            while True:
                stdout_line = fetch.stdout.readline()
                if fetch.poll() is not None:
                    break
                fetch_text += stdout_line
                new_val = progress.get_fraction() + fraction
                GLib.idle_add(self.update_progress, progress, new_val, stdout_line.strip())
            if fetch.returncode != 0:
                stderr_line = fetch.stderr.read()
                fetch_text += stderr_line
                update_fail = open(f'{home}/update.failed', 'w')
                update_fail.writelines(fetch_text)
                update_fail.close()
                fail = True
                GLib.idle_add(self.win.destroy)
                GLib.idle_add(self.stop_tread, fail, update_pkg, reboot)
                return
        txt = _("Fetching package updates")
        new_val = progress.get_fraction() + fraction
        GLib.idle_add(self.update_progress, progress, new_val, txt)
        sleep(1)
        fetch = Popen(
            f'{env}pkg-static upgrade -Fy{option}{packages}',
            shell=True,
            stdout=PIPE,
            stderr=PIPE,
            close_fds=True,
            universal_newlines=True
        )
        fetch_text = ""
        while True:
            stdout_line = fetch.stdout.readline()
            if fetch.poll() is not None:
                break
            fetch_text += stdout_line
            new_val = progress.get_fraction() + fraction
            GLib.idle_add(self.update_progress, progress, new_val, stdout_line.strip())
        if fetch.returncode != 0:
            stderr_line = fetch.stderr.read()
            fetch_text += stderr_line
            update_fail = open(f'{home}/update.failed', 'w')
            update_fail.writelines(fetch_text)
            update_fail.close()
            fail = True
        else:
            new_val = progress.get_fraction() + fraction
            txt = _("Package updates downloaded")
            GLib.idle_add(self.update_progress, progress, new_val, txt)
            sleep(1)
            new_val = progress.get_fraction() + fraction
            txt = _("Installing package updates")
            GLib.idle_add(self.update_progress, progress, new_val, txt)
            sleep(1)
            while True:
                install = Popen(
                    f'{env}pkg-static upgrade -y{option}{packages}',
                    shell=True,
                    stdout=PIPE,
                    stderr=PIPE,
                    close_fds=True,
                    universal_newlines=True
                )
                install_text = ""
                while True:
                    stdout_line = install.stdout.readline()
                    if install.poll() is not None:
                        break
                    install_text += stdout_line
                    new_val = progress.get_fraction() + fraction
                    GLib.idle_add(self.update_progress, progress, new_val, stdout_line.strip())
                if install.returncode == 3:
                    stderr_line = install.stderr.readline()
                    if 'Fail to create temporary file' in stderr_line:
                        raw_line = install_text.splitlines()[-2]
                        failed_package = raw_line.split()[2].replace(':', '')
                        pkg_rquery = run(
                            f'{env}pkg-static rquery -x "%n" "{failed_package}"',
                            shell=True,
                            stdout=PIPE,
                            stderr=PIPE,
                            universal_newlines=True
                        )
                        package_name = pkg_rquery.stdout.strip()
                        reinstall = Popen(
                            f'{env}pkg-static delete -y {package_name} ;'
                            f'{env}pkg-static install -y {package_name}',
                            shell=True,
                            stdout=PIPE,
                            stderr=PIPE,
                            close_fds=True,
                            universal_newlines=True
                        )
                        reinstall_text = ""
                        while True:
                            stdout_line = reinstall.stdout.readline()
                            if reinstall.poll() is not None:
                                break
                            reinstall_text += stdout_line
                            new_val = progress.get_fraction() + fraction
                            GLib.idle_add(self.update_progress, progress, new_val, stdout_line.strip())
                        if reinstall.returncode != 0:
                            reinstall_text += reinstall.stderr.readline()
                            update_fail = open(f'{home}/update.failed', 'w')
                            update_fail.writelines(reinstall_text)
                            update_fail.close()
                            fail = True
                            break
                        else:
                            new_val = progress.get_fraction() + fraction
                            txt = _("Reinstalling")
                            txt += f" {failed_package} "
                            txt += _("completed")
                            GLib.idle_add(self.update_progress, progress, new_val, txt)
                            sleep(1)
                elif install.returncode != 0:
                    stderr_line = install.stderr.readline()
                    install_text += stderr_line
                    update_fail = open(f'{home}/update.failed', 'w')
                    update_fail.writelines(install_text)
                    update_fail.close()
                    fail = True
                    break
                else:
                    new_val = progress.get_fraction() + fraction
                    txt = _("Software packages upgrade completed")
                    GLib.idle_add(self.update_progress, progress, new_val, txt)
                    sleep(1)
                    break
        GLib.idle_add(self.win.destroy)
        GLib.idle_add(self.stop_tread, fail, update_pkg, reboot)

    def stop_tread(self, fail: bool, update_pkg: bool, reboot: bool):
        """
        The function to stop the thread.
        :param fail: True if update failed.
        :param update_pkg: True if update pkg was updated first..
        :param reboot: True if system needs to be rebooted after update completed.
        """
        self.thr.join()
        if updating():
            unlock_update_station()
        if fail is True:
            Data.update_started = False
            Data.stop_pkg_refreshing = False
            FailedUpdate()
        else:
            if update_pkg is True and check_for_update() is True:
                Data.packages_dictionary = get_pkg_upgrade_data()
                StartCheckUpdate()
            else:
                Data.update_started = False
                Data.stop_pkg_refreshing = False
                if reboot is True:
                    RestartSystem()
                else:
                    UpdateCompleted()


class FailedUpdate:
    """
    FailedUpdate class for failed update window.
    """

    def get_detail(self, widget):
        Popen(f'sudo -u {username} xdg-open {home}/update.failed', shell=True)

    def on_close(self, widget):
        """
        The function to close the window.
        :param widget: The window widget.
        """
        if Data.close_session is True:
            Gtk.main_quit()
        else:
            self.window.destroy()

    def __init__(self):
        """
        The constructor of the FailedUpdate class.
        """
        self.window = Gtk.Window()
        self.window.set_position(Gtk.WindowPosition.CENTER)
        self.window.connect("destroy", self.on_close)
        self.window.set_title(_("Update Failed"))
        self.window.set_default_icon_name('system-software-update')
        vBox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.window.add(vBox)
        label = Gtk.Label()
        failed_text = _("""Press "Detail" to get information about the failure.
        Get help at https://forums.ghostbsd.org.""")
        label.set_markup(failed_text)
        vBox.set_border_width(5)
        vBox.pack_start(label, False, False, 5)
        hBox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=0)
        vBox.pack_start(hBox, False, True, 5)
        restart = Gtk.Button(label=_("Detail"))
        restart.connect("clicked", self.get_detail)
        continue_button = Gtk.Button(label=_("Close"))
        continue_button.connect("clicked", self.on_close)
        hBox.pack_end(continue_button, False, False, 5)
        hBox.pack_end(restart, False, False, 5)
        self.window.show_all()


class RestartSystem:
    """
    RestartSystem class for restarting system window.
    """
    def on_reboot(self, widget):
        """
        The function to reboot the system.
        :param widget: The window widget.
        """
        Popen('shutdown -r now', shell=True)
        Gtk.main_quit()

    def on_close(self, widget):
        """
        The function to close the window.
        :param widget: The window widget.
        """
        if Data.close_session is True:
            Gtk.main_quit()
        else:
            self.window.destroy()

    def __init__(self):
        """
        The constructor of the RestartSystem class.
        """
        self.window = Gtk.Window()
        self.window.set_position(Gtk.WindowPosition.CENTER)
        self.window.connect("destroy", self.on_close)
        self.window.set_title(_("Update Completed"))
        self.window.set_default_icon_name('system-software-update')
        vBox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.window.add(vBox)
        reboot_text = _("The computer needs to restart to run on the updated software.")
        label = Gtk.Label(label=reboot_text)
        vBox.set_border_width(5)
        vBox.pack_start(label, False, False, 5)
        hBox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=0)
        vBox.pack_start(hBox, False, True, 5)
        restart = Gtk.Button(label=_("Restart Now"))
        restart.connect("clicked", self.on_reboot)
        continue_button = Gtk.Button(label=_("Restart Later"))
        continue_button.connect("clicked", self.on_close)
        hBox.pack_end(restart, False, False, 5)
        hBox.pack_end(continue_button, False, False, 5)
        self.window.show_all()


class UpdateCompleted:
    """
    Class for update completed window.
    """

    def on_close(self, widget: Gtk.Widget):
        """
        The function to close the window.
        :param widget: The window widget.
        """
        if Data.close_session is True:
            Gtk.main_quit()
        else:
            self.window.destroy()

    def __init__(self):
        """
        The constructor of the UpdateCompleted class.
        """
        self.window = Gtk.Window()
        self.window.set_position(Gtk.WindowPosition.CENTER)
        self.window.connect("destroy", self.on_close)
        self.window.set_title(_("Update Completed"))
        self.window.set_default_icon_name('system-software-update')
        vBox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.window.add(vBox)
        rtxt = _("""All software on this system is up to date.""")
        label = Gtk.Label(label=rtxt)
        vBox.set_border_width(5)
        vBox.pack_start(label, False, False, 5)
        hBox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=0)
        vBox.pack_start(hBox, False, True, 5)
        close_button = Gtk.Button(label=_("Close"))
        close_button.connect("clicked", self.on_close)
        hBox.pack_end(close_button, False, False, 5)
        self.window.show_all()


class NoUpdateAvailable:
    """
    Class for no update available window.
    """

    def __init__(self):
        """
        The constructor of the NoUpdateAvailable class.
        """
        window = Gtk.Window()
        window.set_position(Gtk.WindowPosition.CENTER)
        window.connect("destroy", Gtk.main_quit)
        window.set_title(_("No Update Available"))
        box1 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        window.add(box1)
        box2 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        label = Gtk.Label(label=_("No update available. This system is up to date."))
        box2.pack_start(label, False, False, 0)
        box2 = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, True, 0)
        ok_button = Gtk.Button(label=_("Close"))
        ok_button.connect("clicked", Gtk.main_quit)
        box2.pack_end(ok_button, False, False, 0)
        window.show_all()


class StartCheckUpdate:
    """
    Class for start check for update window.
    """
    def close_application(self, widget: Gtk.Widget, event) -> bool:
        """
        The function to close the window.
        :param widget: The window widget.
        """
        if updating():
            unlock_update_station()
        Gtk.main_quit()
        return True

    def __init__(self):
        """
        The constructor of the StartCheckUpdate class.
        """
        self.win = Gtk.Window()
        self.win.connect("delete-event", self.close_application)
        self.win.set_size_request(500, 75)
        self.win.set_resizable(False)
        self.win.set_title(_("Looking For Updates"))
        self.win.set_border_width(0)
        self.win.set_position(Gtk.WindowPosition.CENTER)
        self.win.set_default_icon_name('system-software-update')
        box1 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.win.add(box1)
        box2 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        self.pbar = Gtk.ProgressBar()
        self.pbar.set_show_text(True)
        self.pbar.set_fraction(0.0)
        box2.pack_start(self.pbar, False, False, 0)
        self.win.show_all()
        self.thr = threading.Thread(
            target=self.check_for_update,
            args=[self.pbar],
            daemon=True
        )
        self.thr.start()

    def update_progress(self, progress: Gtk.ProgressBar, text: str):
        """
        The function to update the progress bar.
        :param progress: The progress bar.
        :param text: the text to be displayed on the progress bar.
        """
        progress.set_text(text)
        fraction = progress.get_fraction() + 0.2
        progress.set_fraction(fraction)

    def check_for_update(self, progress: Gtk.ProgressBar):
        """
        The function to check for update and update the progress bar.
        :param progress: The progress bar.
        """
        GLib.idle_add(self.update_progress, progress, _('Checking if the repository is online'))
        sleep(1)
        if network_stat() == 'UP' and repo_online() is True:
            GLib.idle_add(self.update_progress, progress, _('The repository is online'))
            sleep(1)
            if repository_is_syncing() is True:
                GLib.idle_add(self.update_progress, progress, _('The mirror is Syncing'))
                GLib.idle_add(self.stop_tread, MirrorSyncing)
            else:
                if updating():
                    GLib.idle_add(self.update_progress, progress, _('Updates are already running'))
                    GLib.idle_add(self.stop_tread, UpdateStationOpen)
                else:
                    GLib.idle_add(self.update_progress, progress, _('Checking for updates'))
                    update_available = check_for_update()
                    if update_available:
                        GLib.idle_add(self.update_progress, progress, _('Getting the list of packages'))
                        Data.packages_dictionary = get_pkg_upgrade_data()
                        look_update_station()
                        GLib.idle_add(self.update_progress, progress, _('Open the update window'))
                        GLib.idle_add(self.stop_tread, UpdateWindow)
                    elif not update_available and update_available is not None:
                        GLib.idle_add(self.update_progress, progress, _('No update found'))
                        GLib.idle_add(self.stop_tread, NoUpdateAvailable)
                    else:
                        GLib.idle_add(self.stop_tread, SomethingIsWrong)
        else:
            GLib.idle_add(self.update_progress, progress, _('The Mirror is unreachable'))
            GLib.idle_add(self.stop_tread, ServerUnreachable)

    def stop_tread(self, start_window: object):
        """
        The function to stop the thread.
        :param start_window: The start window object.
        """
        start_window()
        self.win.hide()
        self.thr.join()


class UpdateStationOpen:
    """
    Class for update station already started window.
    """
    def on_close(self, widget):
        """
        The function to close the window.
        :param widget: The window widget.
        """
        if Data.close_session is True:
            Gtk.main_quit()
        else:
            self.window.destroy()

    def __init__(self):
        """
        The constructor of the UpdateStationOpen class.
        """
        self.window = Gtk.Window()
        self.window.set_position(Gtk.WindowPosition.CENTER)
        self.window.connect("destroy", self.on_close)
        self.window.set_title(_("Update Station already started"))
        box1 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.window.add(box1)
        box2 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        label = Gtk.Label(label=_("Update Station already open."))
        box2.pack_start(label, False, False, 0)
        box2 = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, True, 0)
        ok_button = Gtk.Button(label=_("Close"))
        ok_button.connect("clicked", self.on_close)
        box2.pack_end(ok_button, False, False, 0)
        self.window.show_all()


class MirrorSyncing:
    """
    Class for the mirror is syncing warning window.
    """

    def __init__(self):
        """
        The constructor of the MirrorSyncing class.
        """
        window = Gtk.Window()
        window.set_position(Gtk.WindowPosition.CENTER)
        window.connect("destroy", Gtk.main_quit)
        window.set_title(_("Server Unreachable"))
        box1 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        window.add(box1)
        box2 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        label = Gtk.Label(label=_("Packages mirrors are syncing with new packages"))
        box2.pack_start(label, False, False, 0)
        box2 = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, True, 0)
        ok_button = Gtk.Button(label=_("Close"))
        ok_button.connect("clicked", Gtk.main_quit)
        box2.pack_end(ok_button, False, False, 0)
        window.show_all()


class ServerUnreachable:
    """
    Class for the server unreachable warning window.
    """

    def __init__(self):
        """
        The constructor of the ServerUnreachable class.
        """
        window = Gtk.Window()
        window.set_position(Gtk.WindowPosition.CENTER)
        window.connect("destroy", Gtk.main_quit)
        window.set_title(_("Server Unreachable"))
        box1 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        window.add(box1)
        box2 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        label = Gtk.Label(label=_("The server is unreachable. Your internet could\nbe down or software package server is down."))
        box2.pack_start(label, False, False, 0)
        box2 = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, True, 0)
        ok_button = Gtk.Button(label=_("Close"))
        ok_button.connect("clicked", Gtk.main_quit)
        box2.pack_end(ok_button, False, False, 0)
        window.show_all()


class SomethingIsWrong:
    """
    Class for the something is wrong warning window.
    """

    def __init__(self):
        """
        The constructor of the SomethingIsWrong class.
        """
        window = Gtk.Window()
        window.set_position(Gtk.WindowPosition.CENTER)
        window.connect("destroy", Gtk.main_quit)
        window.set_title(_("Something Is Wrong"))
        box1 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        window.add(box1)
        box2 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        box2.set_border_width(10)
        box1.pack_start(box2, True, True, 0)
        label = Gtk.Label(label=_("If you see this message it means that something is wrong.\n Please look at pkg upgrade output."))
        box2.pack_start(label, False, False, 0)
        box2 = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        box2.set_border_width(5)
        box1.pack_start(box2, False, True, 0)
        ok_button = Gtk.Button(label=_("Close"))
        ok_button.connect("clicked", Gtk.main_quit)
        box2.pack_end(ok_button, False, False, 0)
        window.show_all()


class NotRoot(Gtk.Window):
    """
    Class for the user is not root warning window.
    """
    def __init__(self):
        """
        The constructor of the NotRoot class.
        """
        Gtk.Window.__init__(self)
        self.set_title(_("Software Station"))
        self.connect("delete-event", Gtk.main_quit)
        self.set_size_request(200, 80)
        box1 = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.add(box1)
        label = Gtk.Label(label=_('You need to be root'))
        box1.pack_start(label, True, True, 0)
        hBox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=0)
        box1.pack_end(hBox, False, False, 5)
        ok_button = Gtk.Button(label=_("OK"))
        apply_img = Gtk.Image(icon_name='gtk-ok')
        ok_button.set_image(apply_img)
        ok_button.connect("clicked", Gtk.main_quit)
        hBox.pack_end(ok_button, False, False, 5)
        self.show_all()


arg = sys.argv
UsageMSG = f"""
Usage for {arg[0]}:

Available Commands:

check-now       - Look for update now

"""

if os.geteuid() == 0:
    if len(arg) == 1:
        if socket.gethostname() != 'livecd':
            Data.close_session = False
            tray = TrayIcon()
            tray.threading_update()
        else:
            exit()
    elif len(arg) == 2 and arg[1] == "check-now":
        Data.close_session = True
        StartCheckUpdate()
    else:
        print(UsageMSG)
        sys.exit(0)
else:
    NotRoot()
Gtk.main()
